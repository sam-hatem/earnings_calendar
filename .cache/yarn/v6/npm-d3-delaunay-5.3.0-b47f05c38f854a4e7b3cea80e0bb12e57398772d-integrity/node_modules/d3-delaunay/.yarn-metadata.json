{
  "manifest": {
    "name": "d3-delaunay",
    "version": "5.3.0",
    "description": "Compute the Voronoi diagram of a set of two-dimensional points.",
    "keywords": [
      "voronoi",
      "delaunay",
      "geometry"
    ],
    "homepage": "https://github.com/d3/d3-delaunay",
    "repository": {
      "type": "git",
      "url": "https://github.com/d3/d3-delaunay.git"
    },
    "license": "ISC",
    "author": {
      "name": "Mike Bostock",
      "url": "https://bost.ocks.org/mike"
    },
    "files": [
      "dist/**/*.js",
      "src/**/*.js"
    ],
    "contributors": [
      {
        "name": "Vladimir Agafonkin",
        "url": "https://agafonkin.com"
      },
      {
        "name": "Philippe Rivière",
        "url": "https://visionscarto.net"
      }
    ],
    "main": "dist/d3-delaunay.js",
    "unpkg": "dist/d3-delaunay.min.js",
    "module": "src/index.js",
    "dependencies": {
      "delaunator": "4"
    },
    "sideEffects": false,
    "devDependencies": {
      "@observablehq/tape": "~0.0.1",
      "eslint": "6",
      "esm": "3",
      "rollup": "1",
      "rollup-plugin-node-resolve": "5",
      "rollup-plugin-terser": "5"
    },
    "scripts": {
      "test": "tape -r esm 'test/**/*-test.js' && eslint src test",
      "prepublishOnly": "yarn test && rm -rf dist && rollup -c",
      "postpublish": "git push && git push --tags && zip -j dist/${npm_package_name}.zip -- LICENSE README.md dist/${npm_package_name}.js dist/${npm_package_name}.min.js"
    },
    "_registry": "npm",
    "_loc": "/home/jovyan/.cache/yarn/v6/npm-d3-delaunay-5.3.0-b47f05c38f854a4e7b3cea80e0bb12e57398772d-integrity/node_modules/d3-delaunay/package.json",
    "readmeFilename": "README.md",
    "readme": "# d3-delaunay\n\n<p align=\"center\"><img src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/voronator.jpg\" width=\"300\">\n<p align=\"center\">Georgy “The Voronator” Voronoy\n\nThis is a fast, no-dependency library for computing the [Voronoi diagram](https://en.wikipedia.org/wiki/Voronoi_diagram) of a set of two-dimensional points. It is based on [Delaunator](https://github.com/mapbox/delaunator), a fast library for computing the [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation) using [sweep algorithms](https://github.com/mapbox/delaunator/blob/master/README.md#papers). The Voronoi diagram is constructed by connecting the circumcenters of adjacent triangles in the Delaunay triangulation.\n\nFor an interactive explanation of how this library works, see [The Delaunay’s Dual](https://observablehq.com/@mbostock/the-delaunays-dual).\n\n## Installing\n\nTo install, `npm install d3-delaunay` or `yarn add d3-delaunay`. You can also download the [latest release](https://github.com/d3/d3-delaunay/releases/latest) or load directly from [unpkg](https://unpkg.com/d3-delaunay/). AMD, CommonJS and ES6+ environments are supported. In vanilla, a `d3` global is exported.\n\n```js\nimport {Delaunay} from \"d3-delaunay\";\n\nconst points = [[0, 0], [0, 1], [1, 0], [1, 1]];\nconst delaunay = Delaunay.from(points);\nconst voronoi = delaunay.voronoi([0, 0, 960, 500]);\n```\n\n## API Reference\n\n### Delaunay\n\n<a href=\"#new_Delaunay\" name=\"new_Delaunay\">#</a> new <b>Delaunay</b>(<i>points</i>) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the Delaunay triangulation for the given flat array [*x0*, *y0*, *x1*, *y1*, …] of *points*.\n\n```js\nconst delaunay = new Delaunay(Float64Array.of(0, 0, 0, 1, 1, 0, 1, 1));\n```\n\n<a href=\"#delaunay_from\" name=\"delaunay_from\">#</a> Delaunay.<b>from</b>(<i>points</i>[, <i>fx</i>[, <i>fy</i>[, <i>that</i>]]]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the Delaunay triangulation for the given array or iterable of *points*. If *fx* and *fy* are not specified, then *points* is assumed to be an array of two-element arrays of numbers: [[*x0*, *y0*], [*x1*, *y1*], …]. Otherwise, *fx* and *fy* are functions that are invoked for each element in the *points* array in order, and must return the respective *x*- and *y*-coordinate for each point. If *that* is specified, the functions *fx* and *fy* are invoked with *that* as *this*. (See [Array.from](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/from) for reference.)\n\n```js\nconst delaunay = Delaunay.from([[0, 0], [0, 1], [1, 0], [1, 1]]);\n```\n\n<a href=\"#delaunay_points\" name=\"delaunay_points\">#</a> <i>delaunay</i>.<b>points</b>\n\nThe coordinates of the points as an array [*x0*, *y0*, *x1*, *y1*, …]. Typically, this is a Float64Array, however you can use any array-like type in the [constructor](#new_Delaunay).\n\n<a href=\"#delaunay_halfedges\" name=\"delaunay_halfedges\">#</a> <i>delaunay</i>.<b>halfedges</b>\n\nThe halfedge indexes as an Int32Array [*j0*, *j1*, …]. For each index 0 ≤ *i* < *halfedges*.length, there is a halfedge from triangle vertex *j* = *halfedges*[*i*] to triangle vertex *i*. Equivalently, this means that triangle ⌊*i* / 3⌋ is adjacent to triangle ⌊*j* / 3⌋. If *j* is negative, then triangle ⌊*i* / 3⌋ is an exterior triangle on the [convex hull](#delaunay_hull). For example, to render the internal edges of the Delaunay triangulation:\n\n```js\nconst {points, halfedges, triangles} = delaunay;\nfor (let i = 0, n = halfedges.length; i < n; ++i) {\n  const j = halfedges[i];\n  if (j < i) continue;\n  const ti = triangles[i];\n  const tj = triangles[j];\n  context.moveTo(points[ti * 2], points[ti * 2 + 1]);\n  context.lineTo(points[tj * 2], points[tj * 2 + 1]);\n}\n```\n\nSee also [*delaunay*.render](#delaunay_render).\n\n<a href=\"#delaunay_hull\" name=\"delaunay_hull\">#</a> <i>delaunay</i>.<b>hull</b>\n\nAn Int32Array of point indexes that form the convex hull in counterclockwise order. If the points are collinear, returns them ordered.\n\nSee also [*delaunay*.renderHull](#delaunay_renderHull).\n\n<a href=\"#delaunay_triangles\" name=\"delaunay_triangles\">#</a> <i>delaunay</i>.<b>triangles</b>\n\nThe triangle vertex indexes as an Uint32Array [*i0*, *j0*, *k0*, *i1*, *j1*, *k1*, …]. Each contiguous triplet of indexes *i*, *j*, *k* forms a counterclockwise triangle. The coordinates of the triangle’s points can be found by going through [*delaunay*.points](#delaunay_points). For example, to render triangle *i*:\n\n```js\nconst {points, triangles} = delaunay;\nconst t0 = triangles[i * 3 + 0];\nconst t1 = triangles[i * 3 + 1];\nconst t2 = triangles[i * 3 + 2];\ncontext.moveTo(points[t0 * 2], points[t0 * 2 + 1]);\ncontext.lineTo(points[t1 * 2], points[t1 * 2 + 1]);\ncontext.lineTo(points[t2 * 2], points[t2 * 2 + 1]);\ncontext.closePath();\n```\n\nSee also [*delaunay*.renderTriangle](#delaunay_renderTriangle).\n\n<a href=\"#delaunay_inedges\" name=\"delaunay_inedges\">#</a> <i>delaunay</i>.<b>inedges</b>\n\nThe incoming halfedge indexes as a Int32Array [*e0*, *e1*, *e2*, …]. For each point *i*, *inedges*[*i*] is the halfedge index *e* of an incoming halfedge. For coincident points, the halfedge index is -1; for points on the convex hull, the incoming halfedge is on the convex hull; for other points, the choice of incoming halfedge is arbitrary. The *inedges* table can be used to traverse the Delaunay triangulation; see also [*delaunay*.neighbors](#delaunay_neighbors).\n\n<a href=\"#delaunay_find\" name=\"delaunay_find\">#</a> <i>delaunay</i>.<b>find</b>(<i>x</i>, <i>y</i>[, <i>i</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the index of the input point that is closest to the specified point ⟨*x*, *y*⟩. The search is started at the specified point *i*. If *i* is not specified, it defaults to zero.\n\n<a href=\"#delaunay_neighbors\" name=\"delaunay_neighbors\">#</a> <i>delaunay</i>.<b>neighbors</b>(<i>i</i>) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns an iterable over the indexes of the neighboring points to the specified point *i*. The iterable is empty if *i* is a coincident point.\n\n<a href=\"#delaunay_render\" name=\"delaunay_render\">#</a> <i>delaunay</i>.<b>render</b>([<i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\n<img alt=\"delaunay.render\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/delaunay-mesh.png\">\n\nRenders the edges of the Delaunay triangulation to the specified *context*. The specified *context* must implement the *context*.moveTo and *context*.lineTo methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#delaunay_renderHull\" name=\"delaunay_renderHull\">#</a> <i>delaunay</i>.<b>renderHull</b>([<i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\n<img alt=\"delaunay.renderHull\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/delaunay-hull.png\">\n\nRenders the convex hull of the Delaunay triangulation to the specified *context*. The specified *context* must implement the *context*.moveTo and *context*.lineTo methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#delaunay_renderTriangle\" name=\"delaunay_renderTriangle\">#</a> <i>delaunay</i>.<b>renderTriangle</b>(<i>i</i>[, <i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\n<img alt=\"delaunay.renderTriangle\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/delaunay-triangle.png\">\n\nRenders triangle *i* of the Delaunay triangulation to the specified *context*. The specified *context* must implement the *context*.moveTo, *context*.lineTo and *context*.closePath methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#delaunay_renderPoints\" name=\"delaunay_renderPoints\">#</a> <i>delaunay</i>.<b>renderPoints</b>(\\[<i>context</i>\\]\\[, <i>radius</i>\\]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nRenders the input points of the Delaunay triangulation to the specified *context* as circles with the specified *radius*. If *radius* is not specified, it defaults to 2. The specified *context* must implement the *context*.moveTo and *context*.arc methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#delaunay_hullPolygon\" name=\"delaunay_hullPolygon\">#</a> <i>delaunay</i>.<b>hullPolygon()</b> [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the closed polygon [[*x0*, *y0*], [*x1*, *y1*], …, [*x0*, *y0*]] representing the convex hull.\n\n<a href=\"#delaunay_trianglePolygons\" name=\"delaunay_trianglePolygons\">#</a> <i>delaunay</i>.<b>trianglePolygons()</b> [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns an iterable over the [polygons for each triangle](#delaunay_trianglePolygon), in order.\n\n<a href=\"#delaunay_trianglePolygon\" name=\"delaunay_trianglePolygon\">#</a> <i>delaunay</i>.<b>trianglePolygon(<i>i</i>)</b> [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the closed polygon [[*x0*, *y0*], [*x1*, *y1*], [*x2*, *y2*], [*x0*, *y0*]] representing the triangle *i*.\n\n<a href=\"#delaunay_update\" name=\"delaunay_update\">#</a> <i>delaunay</i>.<b>update</b>() [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nUpdates the triangulation after the points have been modified in-place.\n\n<a href=\"#delaunay_voronoi\" name=\"delaunay_voronoi\">#</a> <i>delaunay</i>.<b>voronoi</b>([<i>bounds</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js \"Source\")\n\nReturns the [Voronoi diagram](#voronoi) for the associated [points](#delaunay_points). When rendering, the diagram will be clipped to the specified *bounds* = [*xmin*, *ymin*, *xmax*, *ymax*]. If *bounds* is not specified, it defaults to [0, 0, 960, 500]. See [To Infinity and Back Again](https://observablehq.com/@mbostock/to-infinity-and-back-again) for an interactive explanation of Voronoi cell clipping.\n\nThe Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.\n\n### Voronoi\n\n<a href=\"#voronoi_delaunay\" name=\"voronoi_delaunay\">#</a> <i>voronoi</i>.<b>delaunay</b>\n\nThe Voronoi diagram’s associated [Delaunay triangulation](#delaunay).\n\n<a href=\"#voronoi_circumcenters\" name=\"voronoi_circumcenters\">#</a> <i>voronoi</i>.<b>circumcenters</b>\n\nThe [circumcenters](http://mathworld.wolfram.com/Circumcenter.html) of the Delaunay triangles as a Float64Array [*cx0*, *cy0*, *cx1*, *cy1*, …]. Each contiguous pair of coordinates *cx*, *cy* is the circumcenter for the corresponding triangle. These circumcenters form the coordinates of the Voronoi cell polygons.\n\n<a href=\"#voronoi_vectors\" name=\"voronoi_vectors\">#</a> <i>voronoi</i>.<b>vectors</b>\n\nA Float64Array [*vx0*, *vy0*, *wx0*, *wy0*, …] where each non-zero quadruple describes an open (infinite) cell on the outer hull, giving the directions of two open half-lines.\n\n<a href=\"#voronoi_xmin\" name=\"voronoi_xmin\">#</a> <i>voronoi</i>.<b>xmin</b><br>\n<a href=\"#voronoi_ymin\" name=\"voronoi_ymin\">#</a> <i>voronoi</i>.<b>ymin</b><br>\n<a href=\"#voronoi_xmax\" name=\"voronoi_xmax\">#</a> <i>voronoi</i>.<b>xmax</b><br>\n<a href=\"#voronoi_ymax\" name=\"voronoi_ymax\">#</a> <i>voronoi</i>.<b>ymax</b><br>\n\nThe bounds of the viewport [*xmin*, *ymin*, *xmax*, *ymax*] for rendering the Voronoi diagram. These values only affect the rendering methods ([*voronoi*.render](#voronoi_render), [*voronoi*.renderBounds](#voronoi_renderBounds), [*cell*.render](#cell_render)).\n\n<a href=\"#voronoi_contains\" name=\"voronoi_contains\">#</a> <i>voronoi</i>.<b>contains</b>(<i>i</i>, <i>x</i>, <i>y</i>) [<>](https://github.com/d3/d3-delaunay/blob/master/src/cell.js \"Source\")\n\nReturns true if the cell with the specified index *i* contains the specified point ⟨*x*, *y*⟩. (This method is not affected by the associated Voronoi diagram’s viewport [bounds](#voronoi_xmin).)\n\n<a href=\"#voronoi_neighbors\" name=\"voronoi_neighbors\">#</a> <i>voronoi</i>.<b>neighbors</b>(<i>i</i>) [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\nReturns an iterable over the indexes of the cells that share a common edge with the specified cell *i*. Voronoi neighbors are always neighbors on the Delaunay graph, but the converse is false when the common edge has been clipped out by the Voronoi diagram’s viewport.\n\n<a href=\"#voronoi_render\" name=\"voronoi_render\">#</a> <i>voronoi</i>.<b>render</b>([<i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\n<img alt=\"voronoi.render\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/voronoi-mesh.png\">\n\nRenders the mesh of Voronoi cells to the specified *context*. The specified *context* must implement the *context*.moveTo and *context*.lineTo methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#voronoi_renderBounds\" name=\"voronoi_renderBounds\">#</a> <i>voronoi</i>.<b>renderBounds</b>([<i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\n<img alt=\"voronoi.renderBounds\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/voronoi-bounds.png\">\n\nRenders the viewport extent to the specified *context*. The specified *context* must implement the *context*.rect method from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). Equivalent to *context*.rect(*voronoi*.xmin, *voronoi*.ymin, *voronoi*.xmax - *voronoi*.xmin, *voronoi*.ymax - *voronoi*.ymin). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#voronoi_renderCell\" name=\"voronoi_renderCell\">#</a> <i>voronoi</i>.<b>renderCell</b>(<i>i</i>[, <i>context</i>]) [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\n<img alt=\"cell.render\" src=\"https://raw.githubusercontent.com/d3/d3-delaunay/master/img/spectral.png\">\n\nRenders the cell with the specified index *i* to the specified *context*. The specified *context* must implement the *context*.moveTo , *context*.lineTo and *context*.closePath methods from the [CanvasPathMethods API](https://www.w3.org/TR/2dcontext/#canvaspathmethods). If a *context* is not specified, an SVG path string is returned instead.\n\n<a href=\"#voronoi_cellPolygons\" name=\"voronoi_cellPolygons\">#</a> <i>voronoi</i>.<b>cellPolygons</b>() [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\nReturns an iterable over the non-empty [polygons for each cell](#voronoi_cellPolygon), with the cell index as property.\n\n<a href=\"#voronoi_cellPolygon\" name=\"voronoi_cellPolygon\">#</a> <i>voronoi</i>.<b>cellPolygon</b>(<i>i</i>) [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\nReturns the convex, closed polygon [[*x0*, *y0*], [*x1*, *y1*], …, [*x0*, *y0*]] representing the cell for the specified point *i*.\n\n<a href=\"#voronoi_update\" name=\"voronoi_update\">#</a> <i>voronoi</i>.<b>update</b>() [<>](https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js \"Source\")\n\nUpdates the Voronoi diagram and underlying triangulation after the points have been modified in-place — useful for Lloyd’s relaxation.\n\n",
    "licenseText": "Copyright 2018 Observable, Inc.\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/d3-delaunay/-/d3-delaunay-5.3.0.tgz#b47f05c38f854a4e7b3cea80e0bb12e57398772d",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/d3-delaunay/-/d3-delaunay-5.3.0.tgz",
    "hash": "b47f05c38f854a4e7b3cea80e0bb12e57398772d",
    "integrity": "sha512-amALSrOllWVLaHTnDLHwMIiz0d1bBu9gZXd1FiLfXf8sHcX9jrcj81TVZOqD4UX7MgBZZ07c8GxzEgBpJqc74w==",
    "registry": "npm",
    "packageName": "d3-delaunay",
    "cacheIntegrity": "sha512-amALSrOllWVLaHTnDLHwMIiz0d1bBu9gZXd1FiLfXf8sHcX9jrcj81TVZOqD4UX7MgBZZ07c8GxzEgBpJqc74w== sha1-tH8Fw4+FSk57POqA4LsS5XOYdy0="
  },
  "registry": "npm",
  "hash": "b47f05c38f854a4e7b3cea80e0bb12e57398772d"
}